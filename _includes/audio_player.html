<div id="custom-audio-player">
    <h3>我的音樂播放器</h3>
    
<audio id="main-audio" controls src="{{ site.data.music[0].url }}">
        您的瀏覽器不支持 HTML5 音頻。
    </audio>
    
    <div id="player-controls">
        <span id="mode-button" onclick="togglePlayMode()">
            [ 模式: 順序 ]
        </span>
        
        <div id="timer-controls">
            <button class="timer-btn" onclick="setSleepTimer(10)">10分</button>
            <button class="timer-btn" onclick="setSleepTimer(30)">30分</button>
            <button class="timer-btn" onclick="setSleepTimer(60)">60分</button>
            <button id="clear-timer-btn" onclick="clearSleepTimer()">取消定時</button>
        </div>
    
    <ul id="playlist">

    {% for track in site.data.music %}
        <li data-url="{{ track.url }}" onclick="loadTrack('{{ track.url }}', '{{ track.title }}', {{ forloop.index0 }})">
            {{ track.title }} - {{ track.artist }}
        </li>
    {% endfor %}
    </ul>
</div>

<script>
// 獲取 DOM 元素
const audio = document.getElementById('main-audio');
const playerTitle = document.querySelector('#custom-audio-player h3');
const playlistItems = document.querySelectorAll('#playlist li'); 
const modeButton = document.getElementById('mode-button'); 
const timerControls = document.getElementById('timer-controls'); // 新增：定時器容器
const clearTimerButton = document.getElementById('clear-timer-btn'); // 新增：取消按鈕

// 1. 準備數據和狀態追蹤 (保持不變)
const trackList = [
{% for track in site.data.music %}
    { title: "{{ track.title | escape }}", url: "{{ track.url | escape }}" },
{% endfor %}
];

let currentTrackIndex = 0; 
let playMode = 0; 

// *** 新增定時器狀態變數 ***
let sleepTimerId = null; 
// *************************


// --- 輔助函數 (playTrack, getNextRandomIndex, updatePlaylistHighlight 保持不變) ---

// 載入並播放指定索引的歌曲
function playTrack(index) {
    if (index >= 0 && index < trackList.length) {
        currentTrackIndex = index;
        const track = trackList[index];
        audio.src = track.url;
        playerTitle.textContent = `正在播放：${track.title}`;
        audio.play().catch(error => {
            console.error("自動播放失敗，可能是瀏覽器限制：", error);
        });
        updatePlaylistHighlight();
    } else if (index === trackList.length) {
        // 播放到列表結束
        audio.pause(); 
        playerTitle.textContent = "播放列表已結束";
        currentTrackIndex = -1; 
        updatePlaylistHighlight();
    }
}

// 新增隨機播放邏輯
function getNextRandomIndex() {
    let newIndex;
    do {
        newIndex = Math.floor(Math.random() * trackList.length);
    } while (newIndex === currentTrackIndex && trackList.length > 1);
    
    return newIndex;
}

// 更新播放列表的高亮狀態
function updatePlaylistHighlight() {
    playlistItems.forEach((item, index) => {
        item.classList.remove('playing');
        if (index === currentTrackIndex) {
            item.classList.add('playing');
        }
    });
}

// --- 核心邏輯：控制播放順序/循環/隨機 (保持不變) ---

audio.addEventListener('ended', () => {
    if (playMode === 1) {
        audio.currentTime = 0; 
        audio.play();
    } else if (playMode === 2) {
        const nextIndex = getNextRandomIndex();
        playTrack(nextIndex);
    } 
    else {
        if (currentTrackIndex < trackList.length - 1) {
            playTrack(currentTrackIndex + 1); 
        } else {
            playTrack(trackList.length); 
        }
    }
});

// --- 模式切換函數 (保持不變) ---

function togglePlayMode() {
    playMode = (playMode + 1) % 3; 
    
    let modeText;
    let titleMessage;
    
    if (playMode === 1) {
        modeText = "[ 模式: 循環 ]";
        titleMessage = "已切換到單曲循環模式";
    } else if (playMode === 2) {
        modeText = "[ 模式: 隨機 ]";
        titleMessage = "已切換到隨機播放模式";
    } else {
        modeText = "[ 模式: 順序 ]";
        titleMessage = "已切換到順序播放模式";
    }
    
    modeButton.textContent = modeText;
    playerTitle.textContent = titleMessage;
}


// --- *** 新增定時器邏輯 *** ---

// 設置定時器
function setSleepTimer(minutes) {
    // 1. 清除任何現有的定時器
    clearSleepTimer();

    // 2. 計算延遲時間 (毫秒)
    const delayMilliseconds = minutes * 60 * 1000;

    // 3. 設置新的定時器
    sleepTimerId = setTimeout(() => {
        audio.pause(); // 核心：定時器到期，暫停音樂
        playerTitle.textContent = `定時器到期，已暫停播放 (${minutes} 分鐘)`;
        sleepTimerId = null; // 清除 ID
        updateTimerUI(null); // 更新 UI 為未設置狀態
    }, delayMilliseconds);

    // 4. 更新 UI 提示
    updateTimerUI(minutes);
    playerTitle.textContent = `定時器已設置：${minutes} 分鐘後自動關閉`;

    // 確保音樂正在播放，否則定時器沒有意義
    if (audio.paused) {
        audio.play();
    }
}

// 取消定時器
function clearSleepTimer() {
    if (sleepTimerId !== null) {
        clearTimeout(sleepTimerId);
        sleepTimerId = null;
        playerTitle.textContent = "已取消定時器";
        updateTimerUI(null);
    }
}

// 更新定時器按鈕的視覺狀態
function updateTimerUI(minutes) {
    // 移除所有定時按鈕的高亮狀態
    document.querySelectorAll('.timer-btn').forEach(btn => {
        btn.classList.remove('active-timer');
    });

    // 高亮當前設置的按鈕
    if (minutes !== null) {
        const activeBtn = document.querySelector(`.timer-btn[onclick="setSleepTimer(${minutes})"]`);
        if (activeBtn) {
            activeBtn.classList.add('active-timer');
        }
    }
}

// --- 外部呼叫函數 (保持不變) ---

function loadTrack(url, title, index) {
    playTrack(index);
}

// 初始化：載入並高亮第一首歌
updatePlaylistHighlight();

</script>

